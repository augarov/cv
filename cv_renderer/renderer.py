"""
Core CV rendering functionality using Jinja2 templates.
"""

import yaml
import mistune
from pathlib import Path
from typing import Dict, Any, Union
from jinja2 import Environment, FileSystemLoader, select_autoescape
from datetime import datetime


def escape_latex_text(text: str) -> str:
    """Escape special LaTeX characters in plain text."""
    if not isinstance(text, str):
        return text

    # Process backslashes first to avoid double-escaping
    text = text.replace('\\', r'\textbackslash{}')

    # Then process other special characters
    latex_special_chars = {
        '&': r'\&',
        '%': r'\%',
        '$': r'\$',
        '#': r'\#',
        '^': r'\textasciicircum{}',
        '_': r'\_',
        '{': r'\{',
        '}': r'\}',
        '~': r'\textasciitilde{}',
    }

    for char, replacement in latex_special_chars.items():
        text = text.replace(char, replacement)

    return text


class LaTeXRenderer(mistune.HTMLRenderer):
    """Custom renderer for converting markdown to LaTeX."""

    def strong(self, text: str) -> str:
        """Render bold text for LaTeX."""
        return f"\\textbf{{{text}}}"

    def paragraph(self, text: str) -> str:
        """Render paragraph for LaTeX (no special wrapper needed)."""
        return text

    def text(self, text: str) -> str:
        """Render plain text with LaTeX escaping."""
        return escape_latex_text(text)


class HTMLRenderer(mistune.HTMLRenderer):
    """Custom renderer for converting markdown to HTML."""

    def strong(self, text: str) -> str:
        """Render bold text for HTML."""
        return f"<strong>{text}</strong>"


class CVRenderer:
    """CV Renderer using Jinja2 templates."""

    def __init__(self, templates_dir: str = "templates"):
        """Initialize the renderer with templates directory."""
        self.templates_dir = Path(templates_dir)
        self.env = Environment(
            loader=FileSystemLoader(self.templates_dir),
            autoescape=select_autoescape(['html', 'xml']),
            trim_blocks=True,
            lstrip_blocks=True
        )

        # Initialize markdown parsers
        self.latex_markdown = mistune.create_markdown(renderer=LaTeXRenderer())
        self.html_markdown = mistune.create_markdown(renderer=HTMLRenderer())

        # Add custom filters
        self.env.filters['escape_latex'] = escape_latex_text
        self.env.filters['markdown_latex'] = self._markdown_to_latex
        self.env.filters['markdown_html'] = self._markdown_to_html

    def load_data(self, data_file: str) -> Dict[str, Any]:
        """Load CV data from YAML file."""
        with open(data_file, 'r', encoding='utf-8') as f:
            try:
                return yaml.safe_load(f)
            except yaml.YAMLError as e:
                raise ValueError(f"Unable to parse {data_file} as YAML: {e}")

    def render(self, template_name: str, data: Dict[str, Any]) -> str:
        """Render CV using specified template and data."""
        template = self.env.get_template(template_name)
        return template.render(**data)

    def _generate_disclaimer(self, output_file: str, template_name: str) -> str:
        """Generate disclaimer comment based on output file format."""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        output_path = Path(output_file)
        file_extension = output_path.suffix.lower()

        disclaimer_lines = [
            "This file was automatically generated from a template.",
            "DO NOT EDIT THIS FILE DIRECTLY - your changes will be lost!",
            f"Generated on: {timestamp}",
            f"Template: {template_name}",
            f"Generator: cv_renderer"
        ]

        # Choose comment style based on file extension
        if file_extension in ['.tex', '.latex']:
            # LaTeX comment style
            comment_prefix = "% "
            disclaimer = "\n".join([comment_prefix + line for line in disclaimer_lines])
            disclaimer += "\n" + "%" * 60 + "\n\n"
        elif file_extension in ['.html', '.htm']:
            # HTML comment style
            disclaimer = "<!--\n"
            disclaimer += "\n".join(["  " + line for line in disclaimer_lines])
            disclaimer += "\n-->\n\n"
        else:
            # Generic comment style (using # for other formats)
            comment_prefix = "# "
            disclaimer = "\n".join([comment_prefix + line for line in disclaimer_lines])
            disclaimer += "\n" + "#" * 60 + "\n\n"

        return disclaimer

    def render_to_file(self, template_name: str, data: Dict[str, Any], output_file: str):
        """Render CV and save to file with disclaimer comment."""
        rendered = self.render(template_name, data)

        # Add disclaimer at the beginning
        disclaimer = self._generate_disclaimer(output_file, template_name)
        final_content = disclaimer + rendered

        output_path = Path(output_file)
        output_path.parent.mkdir(parents=True, exist_ok=True)

        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(final_content)

        print(f"âœ… CV rendered to: {output_path}")

    def _process_markdown(self, text: str, parser) -> str:
        """Process markdown text with the given parser."""
        if not isinstance(text, str):
            return str(text)
        result = parser(text)
        return str(result).strip()

    def _markdown_to_latex(self, text: str) -> str:
        """Convert markdown text to LaTeX."""
        return self._process_markdown(text, self.latex_markdown)

    def _markdown_to_html(self, text: str) -> str:
        """Convert markdown text to HTML."""
        return self._process_markdown(text, self.html_markdown)